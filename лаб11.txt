#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>
#include <time.h>
#include <fcntl.h>

#define THREADS_PER_BATCH 5
#define DELAY_BETWEEN_BATCHES 2

int pipe_fd[2]; // pipe: pipe_fd[0] — чтение, pipe_fd[1] — запись

// Функция потока (работа + запись в pipe)
void* thread_work(void* arg) {
    int thread_id = *(int*)arg;
    int work_time = 1 + rand() % 5; // 1-5 секунд
    sleep(work_time);

    char msg[100];
    int len = snprintf(msg, sizeof(msg), "Поток %d завершил работу (%d сек)\n", thread_id, work_time);
    write(pipe_fd[1], msg, len); // Отправляем сообщение в pipe

    free(arg);
    return NULL;
}

// Функция для чтения из pipe (в отдельном потоке)
void* pipe_reader(void* arg) {
    char buf[1024];
    while (1) {
        ssize_t bytes_read = read(pipe_fd[0], buf, sizeof(buf));
        if (bytes_read > 0) {
            write(STDOUT_FILENO, buf, bytes_read); // Выводим сообщение
        }
        usleep(1000); // Небольшая пауза, чтобы не нагружать CPU
    }
}

int main() {
    srand(time(NULL));
    int thread_counter = 0;
    time_t last_batch_time = time(NULL);

    // Создаём pipe и делаем его неблокирующим
    if (pipe(pipe_fd) == -1) {
        perror("Ошибка создания pipe");
        return 1;
    }
    fcntl(pipe_fd[0], F_SETFL, O_NONBLOCK); // Неблокирующее чтение

    // Запускаем поток для чтения из pipe
    pthread_t reader_thread;
    pthread_create(&reader_thread, NULL, pipe_reader, NULL);
    pthread_detach(reader_thread);

    printf("Родительский процесс (PID: %d)\n", getpid());

    while (1) {
        // Создаём новую партию потоков каждые 2 секунды
        if (time(NULL) - last_batch_time >= DELAY_BETWEEN_BATCHES) {
            for (int i = 0; i < THREADS_PER_BATCH; i++) {
                int* thread_id = malloc(sizeof(int));
                *thread_id = ++thread_counter;

                pthread_t tid;
                if (pthread_create(&tid, NULL, thread_work, thread_id) != 0) {
                    perror("Ошибка создания потока");
                    free(thread_id);
                }
                pthread_detach(tid);
            }
            last_batch_time = time(NULL);
        }
        usleep(1000); // Небольшая пауза, чтобы не нагружать CPU
    }

    return 0;
}