#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>
#include <time.h>

#define THREADS_PER_BATCH 5
#define DELAY_BETWEEN_BATCHES 2

int pipe_fd[2]; // pipe: pipe_fd[0] — чтение, pipe_fd[1] — запись

void* thread_work(void* arg) {
    int thread_id = *(int*)arg;
    int work_time = 1 + rand() % 5;
    sleep(work_time);

    char msg[100];
    int len = snprintf(msg, sizeof(msg), "Поток %d завершил работу (%d сек)\n", thread_id, work_time);
    write(pipe_fd[1], msg, len); // Пишем в pipe

    free(arg);
    return NULL;
}

int main() {
    srand(time(NULL));
    int thread_counter = 0;
    time_t last_batch_time = time(NULL);

    if (pipe(pipe_fd) == -1) {
        perror("Ошибка создания pipe");
        return 1;
    }

    printf("Родительский процесс (PID: %d)\n", getpid());

    while (1) {
        // Создаём новую партию каждые 2 секунды
        if (time(NULL) - last_batch_time >= DELAY_BETWEEN_BATCHES) {
            for (int i = 0; i < THREADS_PER_BATCH; i++) {
                int* thread_id = malloc(sizeof(int));
                *thread_id = ++thread_counter;

                pthread_t tid;
                if (pthread_create(&tid, NULL, thread_work, thread_id) != 0) {
                    perror("Ошибка создания потока");
                    free(thread_id);
                }
                pthread_detach(tid);
            }
            last_batch_time = time(NULL);
        }

        // Читаем из pipe и выводим сообщения мгновенно
        char buf[1024];
        ssize_t bytes_read = read(pipe_fd[0], buf, sizeof(buf));
        if (bytes_read > 0) {
            write(STDOUT_FILENO, buf, bytes_read);
        }
    }

    return 0;
}